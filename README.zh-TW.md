# GameMatchDemo

## 專案簡介

**GameMatchDemo是一個基於 C++ 開發並支援多執行緒的簡易遊戲匹配Demo專案，運行於 Windows 11 平台，使用 SQLite3 作為資料庫。
**它模擬了批次玩家加入匹配隊列、自動組隊、進入戰鬥、戰鬥結果處理及數據保存的流程。
**用以展示實現一個匹配系統的核心邏輯、排程處裡、玩家數據管理、持久化儲存以及多執行緒併發處理等。

## 專案目標

作為個人編程能力和伺服器開發理解的Demo
** 展示 C++ 多執行緒編程和同步機制，處理並發操作。
** 核心邏輯包含玩家創建、狀態管理、分級匹配系統和資料庫讀寫。
** 實現資料持久化，使用SQLite進行玩家資料的讀取和異步回寫。
** 實現排程任務管理器，用於定時執行後台任務 (資料庫回寫) 。

## 核心功能

### 玩家管理器 (PlayerManager)
** 玩家登入/登出機制。
** 管理玩家的在線狀態和遊戲內狀態 (離線/匹配中/戰鬥中/大廳)。
** 處理玩家戰鬥結果並更新分數和勝場。
** 異步回寫 : 當玩家資料有變動時會加入排程，並定時回寫資料庫。

### 戰鬥匹配管理器 (BattleManager)
** 根據玩家階位 (Tier) 進行分級匹配。自動組隊機制 (3v3) 。
** 創建獨立的戰鬥房間 (BattleRoom) 以及戰鬥單位英雄 (Hero) 。
** 各房間獨立執行緒進行簡單模擬戰鬥與結果。
** 戰鬥結束後的勝負判定和結果會同步。

### 資料庫管理器 (DbManager)
** 基於 SQLite 輕量化資料庫實現數據的持久化存儲。
** 提供玩家戰鬥數據的增、刪、查、改介面。
** 初始化時確保資料庫表結構必須存在並會將資料載入遊戲中。

### 任務排程管理器(ScheduleManager)
** 通用的多執行緒安全的任務排程器。
** 支持週期性任務 (ex. 玩家資料回寫) 和一次性任務。

## 專案結構
```
 .
 ├── include/
 │   └── globalDefine.h          # 全域定義
 ├── libs/
 │   └── sqlite/                 # Sqlte資料庫
 │       ├── sqlite3.c
 │       └── sqlite3.h
 ├── src/
 │   ├── managers/
 │   │   ├── battleManager.cpp   # 戰鬥和匹配核心邏輯
 │   │   ├── battleManager.h
 │   │   ├── dbManager.cpp       # SQLite 數據庫操作介面
 │   │   ├── dbManager.h
 │   │   ├── playerManager.cpp   # 玩家數據管理
 │   │   ├── playerManager.h
 │   │   ├── scheduleManager.cpp # 定時任務排程器
 │   │   └── scheduleManager.h
 │   ├── objects/
 │   │   ├── hero.cpp            # 英雄類別
 │   │   ├── hero.h
 │   │   ├── player.cpp          # 玩家類別
 │   │   └── player.h
 │   └── main.cpp                # 應用程式入口，初始化管理器，處理用戶命令
 ├── utils/
 │  ├── utils.cpp                # 工具函式 (時間, 字串處理)
 │  └── utils.h
 ├── README.md
 └── README.zh-TW.md
```
## 待優化部分

這份專案作為一個概念實踐的Demo，旨在快速搭建一個多執行緒伺服器應用，展示基本的玩家管理、戰鬥匹配與數據持久化功能。
在開發過程中，我不斷地意識到有許多可以優化的方向或必須改善的潛在問題，但由於製作這份Demo的時間有限，許多進階的功能無法完全到位。
因此，我針對當前已知未能充分設計與實踐的問題進行檢討，並提出具體的優化方向與實踐建議如下：

---

### 1. Graceful Shutdown 機制
** 現況 : 目前關閉功能只是在 main.cpp 中通過 exit 指令終止了中控，並呼叫了各Manager的release()去停止運作。
** 問題 : 由於沒有實踐完善的停機功能，無法確保所有功能正常退出 (玩家配對或資料庫回寫) ，可能會有資料丟失或死鎖的風險。
** 優化 : 透過一個全域管理的中控台管理伺服器狀態，在收到停機指令時，先調用Manager的shutdown()安全的依序停止服務，並確保資料回存完整後再進行關閉。

---

### 2. 匹配機制的安全性
** 現況 : 基於目的性實作的單純列表配對，由於尚未納入全面狀況考量，因此安全性存在風險。
** 問題 : 缺乏包括主動退出或超時移除在內的玩家安全中途移除機制，可能造成狀態不同步或空指針的問題。
** 優化 : 實現玩家退場的安全機制，必須能夠在加入和移除都保持狀態同步以及維持隊列的完整性。

---

### 3. 匹配機制的效率
** 現況 : 基於目的性實作的定期檢查列表的配對機制，由於尚未納入全面狀況考量，因此匹配的效率不佳。
** 問題 : 由於是單純的列表，沒有積分排序，所以擴展性不佳，也缺乏彈性，且單人與隊伍的兩個階段的每次匹配都是使用遍歷的方式，效率是 O(n) ，並且佔用了大量的空間。
** 優化 : 可以考慮事件驅動，加入積分排序算法以及完善的組隊功能，應該可以節省記憶體並提升匹配的效率達到 O(log N) 的等級。

---

### 4. 資料庫的選用
** 現況 : 基於快速且簡易的搭建，專案使用 SQLite 作為唯一的數據庫，僅負責儲存玩家的戰鬥數據。
** 問題 : SQLite本身是輕量化資料庫，在吞吐量，擴展性以及安全性上都不夠成熟，有併發瓶頸與資料丟失的風險。
** 優化 : 將資料遷移至 MySQL 或 PostgreSQL 等更全面的資料庫伺服器上，並實踐連接池和各種讀寫優化的機制。

---

### 5. 物件池 (pool) 機制
** 現況 : 目前匹配時會頻繁地建立和銷毀包含 BattleRoom 與 Hero 等物件，雖然有採用智能指標來防止記憶體洩漏和空指標問題，但這只有安全層面的考量。
** 問題 : 這種頻繁的動態記憶體分配與釋放操作，會增加 CPU 的負擔，拖慢程式效能，更會提高記憶體碎片化的風險，進而影響系統的長期穩定性。
** 優化 : 導入物件池機制來管理，主要透過物件的預配置數量，當需要時從池中取用，用畢後再將其回收進池中，就可以避免重複的記憶體分配與釋放以及效能負擔。

## 作者

* August Jian(sppaugust@gmail.com)

